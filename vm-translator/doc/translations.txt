### push segment index

@index
D=A       // D=index
@segment
A=M+D     // A=segment[index]
D=M       // D=*(segment[index])
@SP
A=M       // A=*SP
M=D       // **SP=*(segment[index])
@SP
M=M+1     // *SP=*SP+1 (i.e. increment stack pointer)

### pop segment index

@SP
M=M-1   // *SP = *SP - 1 (i.e. decrement stack pointer)
A=M     // A = *SP
D=M     // D = **SP (pop value)
@LCL
D=D+M   // D = **SP + *LCL (i.e. pop value + segment base memory address)
@16
D=D+A   // D= **SP + LCL[16] (i.e. pop value + address to pop to)
@SP
A=M     // A = *SP
A=M     // A = **SP (pop value)
A=D-A   // A = (**SP + LCL[16]) - **SP (i.e. address to pop to)
M=D-A   // *(LCL[16]) = (**SP + LCL[16]) - LCL[16] (i.e. address to pop to = pop value)

### pop constant index



### add (x + y)

 stack
 -----
 | x |    [initial stack state]
 |---|
 | y |
 |---|
 |   | <- SP
 |---|

@SP
AM=M-1  // A= *SP - 1; *SP = *SP - 1; (i.e. decrement stack pointer)
D=M     // D = **SP (i.e. y)
A=A-1   // A = *SP - 1 (i.e. &x)
M=D+M   // x = x + y

### sub (x - y)

@SP
AM=M-1  // A= *SP - 1; *SP = *SP - 1; (i.e. decrement stack pointer)
D=M     // D = **SP (i.e. y)
A=A-1   // A = *SP - 1 (i.e. &x)
M=M-D   // x = x + y

### neg

@SP
A=M-1
M=-M

### eq

### gt

### lt

### and

@SP
AM=M-1  // A= *SP - 1; *SP = *SP - 1; (i.e. decrement stack pointer)
D=M     // D = **SP (i.e. y)
A=A-1   // A = *SP - 1 (i.e. &x)
M=D&M   // x = x + y

### or

@SP
AM=M-1  // A= *SP - 1; *SP = *SP - 1; (i.e. decrement stack pointer)
D=M     // D = **SP (i.e. y)
A=A-1   // A = *SP - 1 (i.e. &x)
M=D|M   // x = x + y

### not

@SP
A=M-1
M=!M

### label

### call name nArgs

### function name nLcls

### goto

### if-goto
